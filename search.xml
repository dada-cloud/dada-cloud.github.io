<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2021/10/17/SEATA/"/>
      <url>/2021/10/17/SEATA/</url>
      
        <content type="html"><![CDATA[<h1 id="SEATA"><a href="#SEATA" class="headerlink" title="SEATA"></a>SEATA</h1><h2 id="一、分布式事物基础"><a href="#一、分布式事物基础" class="headerlink" title="一、分布式事物基础"></a>一、分布式事物基础</h2><div class="story post-story"><h3 id="1-CAP"><a href="#1-CAP" class="headerlink" title="1.CAP"></a>1.CAP</h3><h3 id="2-强一致性和弱一致性"><a href="#2-强一致性和弱一致性" class="headerlink" title="2.强一致性和弱一致性"></a>2.强一致性和弱一致性</h3><h4 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h4><blockquote><p>系统中的某个数据被成功更新后，后续任何对该数据的读取操作都讲得到更新后的值；也成为<code>原子一致性</code>，<code>线性一致性</code></p></blockquote><h5 id="两个要求"><a href="#两个要求" class="headerlink" title="两个要求:"></a>两个要求:</h5><ul><li>任何一次读都能读到某个数据的最近一次写的数据</li><li>系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。</li></ul><p>在任意时刻，所有节点的数据是一样的。例如，对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这就是强一致性</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>一个集群需要对外部提供强一致性，所以只需要集群内部某台服务器的数据法生了改变，那么就要等等集群内其他服务器的数据同步完成后，才能正常的对外提供服务。</li><li>保证强一致性，务必会损耗可用性</li></ul><h4 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h4><blockquote><p>系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。</p><p>但即使过了”不一致时间窗口“这段时间后，后续对该数据的读取也不一定是最新的；</p><p>所以说，可以理解为数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。如12306购买</p></blockquote><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><blockquote><p>是弱一致性的特殊形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值。    </p><p>不保证在任意时刻任意节点的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化 ，就是在一段时间后，节点间的数据会最终达到一致状态   </p></blockquote><h3 id="3-Base理论"><a href="#3-Base理论" class="headerlink" title="3.Base理论"></a>3.Base理论</h3><ul><li>BA：Basic Available <span style= 'color:white;background:green'>基本可用</span><ul><li>整个系统在某些不可抗的情况下，仍然能够保证<code>可用性</code>，即一定时间内仍然能够返回一个明确的结果。<ul><li>“一定时间”可以适当延长，当举行大促时，响应时间可以适当延长</li><li>给部分用户返回一个降级页面，给部分用户直接返回一个降级页面，从而缓解服务器压力。但是是注意，返回降级页面仍然是返回明确结果。例：商品抢购10个，服务器支撑500人，后面的人返回降级页面</li></ul></li></ul></li><li>S：Soft State <span style='color:white;background:green'>柔性状态</span>  <ul><li>是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。</li></ul></li><li>E：Eventual Consisstency <span style='color:white;background:green'>最终一致性</span><ul><li>同一数据的不同副本状态，可以不需要实时一致，但一定要保证经过一定时间后是一致的</li></ul></li></ul><p>Base理论是根据CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可用根据自身的业务特点，采用适当的方式来使系统达到最终一致性</p><h3 id="分布式事物协议"><a href="#分布式事物协议" class="headerlink" title="分布式事物协议"></a>分布式事物协议</h3><blockquote><p><span style='color:green'>背景</span></p><p>在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败，当一个事物跨多个节点时，为了保持事物的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示他们是否把操作结果进行真正的提交或者回滚</p></blockquote><h4 id="二阶段提交-2PC"><a href="#二阶段提交-2PC" class="headerlink" title="二阶段提交  2PC"></a>二阶段提交  <span style='color:white;background:green'>2PC</span></h4><p>二阶段提交协议是常用的分布式事物解决方案，即将事物的提交过程分为两个阶段来进行处理</p><h5 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h5><ul><li>准备阶段</li><li>提交阶段</li></ul><h5 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h5><ul><li>协调者：事物的发起者</li><li>参与者：事务的执行者</li></ul><h5 id="第一阶段-投票阶段"><a href="#第一阶段-投票阶段" class="headerlink" title="第一阶段 投票阶段"></a>第一阶段 <span style='color:white;background:green'>投票阶段</span></h5><p>1.协调者向所有参与者发送事物内容，询问是否可以提交事物，并等待答复</p><p>2.各参与者执行事物操作，将undo和redo信息计入事物日志中（但不提事物）</p><p>3.如果参与者执行，给协调者反馈<strong>同意</strong>，否则反馈<strong>终止</strong>  </p><h5 id="2-第二阶段-提交执行阶段"><a href="#2-第二阶段-提交执行阶段" class="headerlink" title="2.第二阶段 提交执行阶段"></a>2.第二阶段 <span style='color:white;background:green'>提交执行阶段</span></h5><p>当协调者从所有参与者节点获得相应消息都为同意时：</p><p>1.协调者节点向所有参与者节点发出<strong>正式提交（<code>commit</code>）</strong>的请求</p><p>2.参与者正式完成操作，并释放在整个事物期间内占用的资源</p><p>3.参与者节点向协调者节点发送ack完成消息</p><p>4.协调者收到所有参与者反馈的ack完成消息后，完成事物</p><p>如果任一参与者节点在第一节点返回响应消息为终止，或协调者节点在第一阶段的询问超时前无法获取所有参与者节点的响应消息时：</p><p>1.协调者节点向所有参与者节点发出<strong>回滚（<code>rollback</code>）</strong>的请求</p><p>2.参与者节点利用阶段1写入undo信息执行回滚，并释放在整个事物期间内占用的资源。</p><p>3.参与者节点向协调者节点发送ack回滚完成消息</p><p>4.协调者在节点收到所有参与者节点反馈的ack回滚完成消息后，取消事物。</p><p>不管最后结果如何，第二阶段都会结束当前事物。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1.性能问题：执行过程中，所有参与节点都是事物阻塞型的。当参与者占用公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态</p><p>2.可靠性问题：参与者发送故障，协调者需要给每个参与者额外指定超时机制，超时后整个事物失败。协调者发生故障，参与者会一直阻塞下去。需要额外的备机进行容错。</p><p>3.数据一致性问题：二阶段无法解决的问题：协调者在发出<code>commit</code>消息后宕机，而唯一接受到这条消息的参与者也同时宕机，那么即使协调者通过选举协议产生了新的协调者，这条事物的状态也是不确定的，无法确定事物是否已经被提交</p><blockquote><p>缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景</p></blockquote><blockquote><p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域</p></blockquote><h4 id="三阶段提交-3PC"><a href="#三阶段提交-3PC" class="headerlink" title="三阶段提交 3PC"></a>三阶段提交 <span style='color:white;background:green'>3PC</span></h4><p>三阶段提交协议是对二阶段提交协议的改进版本，三阶段提交有两个改动点：</p><ul><li>在协调者和参与者都引入超时机制</li><li>在第一阶段和第二阶段都插入了一个准备阶段，保证了在最后提交阶段之前各参与节点状态是一致的。</li></ul><p><code>3PC</code>把<code>2PC</code>的准备阶段再次一分为二，这样三阶段提交就有 <code>CanCommit</code>，<code>PreCommit</code>，<code>Docommit</code> 三个阶段。</p><p> <img src="C:\Users\81997\AppData\Roaming\Typora\typora-user-images\image-20211016141640548.png" class="lazyload" data-srcset="C:\Users\81997\AppData\Roaming\Typora\typora-user-images\image-20211016141640548.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211016141640548"></p><p><img src="C:\Users\81997\AppData\Roaming\Typora\typora-user-images\image-20211016141651760.png" class="lazyload" data-srcset="C:\Users\81997\AppData\Roaming\Typora\typora-user-images\image-20211016141651760.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211016141651760"></p><h5 id="1-第一阶段-CanCommit阶段"><a href="#1-第一阶段-CanCommit阶段" class="headerlink" title="1.第一阶段: CanCommit阶段"></a>1.第一阶段: <code>CanCommit阶段</code></h5><p>3PC<code>CanCommit</code>阶段和2PC的准备阶段很像。协调者      向各个参与者发送<code>commit</code>请求，参与者如果可用提交事物就返回yea，否则返回no响应。</p><ul><li>事物询问：协调者向所有参与者发出包含事物内容的<code>CanCommit</code>请求，询问是否可以提交事物，并等待所有参与者答复。</li><li>响应反馈：参与者收到<code>CanCommit</code>请求后，如果认为可以执行事物操作则反馈yes并进入预备状态，否则返回no。</li></ul><h5 id="2-第二阶段-PreCommit阶段"><a href="#2-第二阶段-PreCommit阶段" class="headerlink" title="2.第二阶段 PreCommit阶段"></a>2.第二阶段 <code>PreCommit阶段</code></h5><p>协调者根据参与者的反应情况来决定是否可以进行事物的<code>PreCommit</code>操作，根据响应情况，有以下两种情况：</p><ul><li>假如所有参与者均反馈yes。协调者预执行事物。<ul><li>发送预提交请求：协调者向参与者发送<code>PreCommit</code>请求，并进入准备阶段</li><li>事物预提交：参与者接受到<code>PreCommit</code>请求后，会执行事物操作，并将<code>undo</code>和<code>redo</code>信息记录到事物日志中（但不提交事物）</li><li>响应反馈：如果参与者成功的执行了事物操作，则返回ack响应，同时开始等待最终指令。</li></ul></li><li>假如有任何一个参与者向协调者发送了no，或者等待超时后，协调者都没有接受到参与者的响应，那么就执行事物的中断<ul><li>1.发送中断请求：协调者向所有参与者发送<code>abort</code>请求</li><li>2.中断事物：参与者收到来着协调者的<code>abort</code>请求后，或者超时后仍未收到协调者的请求，执行事物中断。</li></ul></li></ul><h5 id="3-第三阶段-DoCommit阶段"><a href="#3-第三阶段-DoCommit阶段" class="headerlink" title="3.第三阶段 DoCommit阶段"></a>3.第三阶段 <code>DoCommit阶段</code></h5><blockquote><p>注意：进入第三阶段后，无论协调者出现问题，还是协调者或者参与者网络出现问题，都会导致参与者无法接收到协调者发出的<code>DoCommit</code>请求或者<code>abort</code>请求。此时参与者都会在等待超时之后，继续执行事物提交。</p></blockquote><ul><li><p>执行提交：</p><p>所有参与者均反馈ack响应，执行真正的事物提交</p><ul><li>发送提交请求：协调者接收到参与者发送的ack响应，那么它将从预提交状态进入提交状态，并向所有参与者发送<code>DoCommit</code>请求</li><li>事物提交：参与者收到<code>Docommit</code>请求后，执行正式的事物提交，并在完成事物提交之后释放掉所有事物资源。</li><li>响应反馈：事物提交完成之后，向协调者发送ack响应</li><li>完成事物：协调者接受到所有参与者的ack响应之后，完成事物。</li></ul></li><li><p>中断事物</p><p>任何一个参与者反馈no，或者等待超时后协调者仍没收到所有参与者的反馈，即中断事物</p><ul><li>发送中断请求：如果协调者处于工作状态，向所有参与者发送<code>abort</code>请求</li><li>事物回滚：参与者收到<code>abort</code>请求后，利用其在第二阶段记录的<code>undo</code>信息来执行事务的回滚操作，并在完成回滚之后释放所有的事物资源</li><li>反馈结果：参与者完成事物回滚后，向协调者反馈ack消息</li><li>中断事物：协调者接收带参与者反馈的ack消息之后，执行事物的中断</li></ul><blockquote><p>注意</p><p>在<code>DoCommit</code>阶段，如果参与者无法及时接受到来自协调者的<code>DoCommit</code>请求，会在等待超时之后，会继续进行事物的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了<code>PreCommit</code>请求，那么协调者生产<code>PreCommit</code>请求的前提条件是在第二阶段开始前，收到了所有参与者的<code>CanCommit</code>响应都是yes）</p><p>一旦参与者收到了<code>PreCommit</code>，意味着他知道大家其实都同意修改了</p><p>所以，进入第三阶段时，由于网络超时等原因导致，参与者没有收到commit或abort，但是他有理由相信:成功提交的几率是很大的</p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>优点：相比较二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或者参与者会中断事物。避免了协调者单点问题，阶段3中协调者出现问题，参与者会继续提交事物</p></blockquote><blockquote><p>缺点：数据不一致问题依然存在，当在参与者收到<code>PreCommit</code>请求后等待<code>DoCommit</code>指令时，此时如果协调者请求中断事物，而协调者无法与参与者正常通信，会导致参与者继续提交事物，造成数据不一致</p></blockquote></li></ul></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
