{"meta":{"title":"达达的个人博客","subtitle":"","description":"","author":"达达","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-10-21T16:19:58.582Z","updated":"2021-10-21T16:19:58.582Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-21T16:21:52.509Z","updated":"2021-10-21T16:21:52.509Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"分布式事务基础","slug":"SEATA","date":"2021-10-16T16:44:41.903Z","updated":"2021-10-21T15:44:10.209Z","comments":true,"path":"2021/10/17/SEATA/","link":"","permalink":"http://example.com/2021/10/17/SEATA/","excerpt":"","text":"一、分布式事物基础1.CAP2.强一致性和弱一致性强一致性 系统中的某个数据被成功更新后，后续任何对该数据的读取操作都讲得到更新后的值；也成为原子一致性，线性一致性 两个要求: 任何一次读都能读到某个数据的最近一次写的数据 系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。 在任意时刻，所有节点的数据是一样的。例如，对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这就是强一致性 总结： 一个集群需要对外部提供强一致性，所以只需要集群内部某台服务器的数据法生了改变，那么就要等等集群内其他服务器的数据同步完成后，才能正常的对外提供服务。 保证强一致性，务必会损耗可用性 弱一致性 系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。 但即使过了”不一致时间窗口“这段时间后，后续对该数据的读取也不一定是最新的； 所以说，可以理解为数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。如12306购买 最终一致性 是弱一致性的特殊形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值。 不保证在任意时刻任意节点的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化 ，就是在一段时间后，节点间的数据会最终达到一致状态 3.Base理论 BA：Basic Available 基本可用 整个系统在某些不可抗的情况下，仍然能够保证可用性，即一定时间内仍然能够返回一个明确的结果。 “一定时间”可以适当延长，当举行大促时，响应时间可以适当延长 给部分用户返回一个降级页面，给部分用户直接返回一个降级页面，从而缓解服务器压力。但是是注意，返回降级页面仍然是返回明确结果。例：商品抢购10个，服务器支撑500人，后面的人返回降级页面 S：Soft State 柔性状态 是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。 E：Eventual Consisstency 最终一致性 同一数据的不同副本状态，可以不需要实时一致，但一定要保证经过一定时间后是一致的 Base理论是根据CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可用根据自身的业务特点，采用适当的方式来使系统达到最终一致性 分布式事物协议 背景 在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败，当一个事物跨多个节点时，为了保持事物的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示他们是否把操作结果进行真正的提交或者回滚 二阶段提交 2PC二阶段提交协议是常用的分布式事物解决方案，即将事物的提交过程分为两个阶段来进行处理 阶段 准备阶段 提交阶段 参与角色 协调者：事物的发起者 参与者：事务的执行者 第一阶段 投票阶段1.协调者向所有参与者发送事物内容，询问是否可以提交事物，并等待答复 2.各参与者执行事物操作，将undo和redo信息计入事物日志中（但不提事物） 3.如果参与者执行，给协调者反馈同意，否则反馈终止 2.第二阶段 提交执行阶段当协调者从所有参与者节点获得相应消息都为同意时： 1.协调者节点向所有参与者节点发出正式提交（commit）的请求 2.参与者正式完成操作，并释放在整个事物期间内占用的资源 3.参与者节点向协调者节点发送ack完成消息 4.协调者收到所有参与者反馈的ack完成消息后，完成事物 如果任一参与者节点在第一节点返回响应消息为终止，或协调者节点在第一阶段的询问超时前无法获取所有参与者节点的响应消息时： 1.协调者节点向所有参与者节点发出回滚（rollback）的请求 2.参与者节点利用阶段1写入undo信息执行回滚，并释放在整个事物期间内占用的资源。 3.参与者节点向协调者节点发送ack回滚完成消息 4.协调者在节点收到所有参与者节点反馈的ack回滚完成消息后，取消事物。 不管最后结果如何，第二阶段都会结束当前事物。 缺点：1.性能问题：执行过程中，所有参与节点都是事物阻塞型的。当参与者占用公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态 2.可靠性问题：参与者发送故障，协调者需要给每个参与者额外指定超时机制，超时后整个事物失败。协调者发生故障，参与者会一直阻塞下去。需要额外的备机进行容错。 3.数据一致性问题：二阶段无法解决的问题：协调者在发出commit消息后宕机，而唯一接受到这条消息的参与者也同时宕机，那么即使协调者通过选举协议产生了新的协调者，这条事物的状态也是不确定的，无法确定事物是否已经被提交 缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景 优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域 三阶段提交 3PC三阶段提交协议是对二阶段提交协议的改进版本，三阶段提交有两个改动点： 在协调者和参与者都引入超时机制 在第一阶段和第二阶段都插入了一个准备阶段，保证了在最后提交阶段之前各参与节点状态是一致的。 3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有 CanCommit，PreCommit，Docommit 三个阶段。 1.第一阶段: CanCommit阶段3PCCanCommit阶段和2PC的准备阶段很像。协调者 向各个参与者发送commit请求，参与者如果可用提交事物就返回yea，否则返回no响应。 事物询问：协调者向所有参与者发出包含事物内容的CanCommit请求，询问是否可以提交事物，并等待所有参与者答复。 响应反馈：参与者收到CanCommit请求后，如果认为可以执行事物操作则反馈yes并进入预备状态，否则返回no。 2.第二阶段 PreCommit阶段协调者根据参与者的反应情况来决定是否可以进行事物的PreCommit操作，根据响应情况，有以下两种情况： 假如所有参与者均反馈yes。协调者预执行事物。 发送预提交请求：协调者向参与者发送PreCommit请求，并进入准备阶段 事物预提交：参与者接受到PreCommit请求后，会执行事物操作，并将undo和redo信息记录到事物日志中（但不提交事物） 响应反馈：如果参与者成功的执行了事物操作，则返回ack响应，同时开始等待最终指令。 假如有任何一个参与者向协调者发送了no，或者等待超时后，协调者都没有接受到参与者的响应，那么就执行事物的中断 1.发送中断请求：协调者向所有参与者发送abort请求 2.中断事物：参与者收到来着协调者的abort请求后，或者超时后仍未收到协调者的请求，执行事物中断。 3.第三阶段 DoCommit阶段 注意：进入第三阶段后，无论协调者出现问题，还是协调者或者参与者网络出现问题，都会导致参与者无法接收到协调者发出的DoCommit请求或者abort请求。此时参与者都会在等待超时之后，继续执行事物提交。 执行提交： 所有参与者均反馈ack响应，执行真正的事物提交 发送提交请求：协调者接收到参与者发送的ack响应，那么它将从预提交状态进入提交状态，并向所有参与者发送DoCommit请求 事物提交：参与者收到Docommit请求后，执行正式的事物提交，并在完成事物提交之后释放掉所有事物资源。 响应反馈：事物提交完成之后，向协调者发送ack响应 完成事物：协调者接受到所有参与者的ack响应之后，完成事物。 中断事物 任何一个参与者反馈no，或者等待超时后协调者仍没收到所有参与者的反馈，即中断事物 发送中断请求：如果协调者处于工作状态，向所有参与者发送abort请求 事物回滚：参与者收到abort请求后，利用其在第二阶段记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事物资源 反馈结果：参与者完成事物回滚后，向协调者反馈ack消息 中断事物：协调者接收带参与者反馈的ack消息之后，执行事物的中断 注意 在DoCommit阶段，如果参与者无法及时接受到来自协调者的DoCommit请求，会在等待超时之后，会继续进行事物的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者生产PreCommit请求的前提条件是在第二阶段开始前，收到了所有参与者的CanCommit响应都是yes） 一旦参与者收到了PreCommit，意味着他知道大家其实都同意修改了 所以，进入第三阶段时，由于网络超时等原因导致，参与者没有收到commit或abort，但是他有理由相信:成功提交的几率是很大的 总结 优点：相比较二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或者参与者会中断事物。避免了协调者单点问题，阶段3中协调者出现问题，参与者会 继续提交事物 缺点：数据不一致问题依然存在，当在参与者收到PreCommit请求后等待DoCommit指令时，此时如果协调者请求中断事物，而协调者无法与参与者正常通信，会导致参与者继续提交事物，造成数据不一致 事物补偿（TCC）TCC方案是一种应用层面侵入业务的两阶段提交。是目前最火的一种柔性事物方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作 第一阶段 Try（尝试）：主要是对业务系统做检测及。资源预留（加锁，锁住资源） 第二阶段 本阶段根据第一阶段的结果，决定是执行confirm还是cancel confirm：执行真正的业务执行业务,释放锁 cancel：是预留资源的取消出问题，释放锁 1.Try阶段 TCC机制中的Try仅是一个初步操作，他和后续的确认一起才能真正的构成一个完整的业务逻辑，这个阶段主要完成： 完成所有业务检查（一致性）。 预留必须业务资源（准备隔离）。 Try尝试执行业务。 2.confirm/cancel阶段 根据Try阶段服务是否全部正常执行，继续执行确认操作confirm或者取消操作cancel confirm 和cancel操作满足幂等性，如果comfirm或者cancel操作失败，将会不断重试直到执行完成。（有性能问题） comfirm：当try阶段服务全部正常执行，执行确认业务逻辑操作 这里使用的资源一定是try阶段预留的业务资源。在TCC事物机制中认为，如果在try阶段能够正常的预留资源，那confirm 一定能完整正确的提交 confirm阶段也可以看成是对try阶段的一个补充，try+confirm一起组成了一个完整的业务逻辑 方案总结 优点： 性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源 数据最终一致性：基于confirm和cancel的幂等性，保证事物最终完成或者取消，保证数据的一致性 可靠性：由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群 缺点：TCC的try,confirm,cancel操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本 Seata术语TC（Transaction Coordinator） 事物协调者：维护全局和分支事物的状态，驱动全局事物提交或者回滚 TM（Transaction Manager）事物管理者：定义全局事物的范围，开始全局事务，提交或者回滚全局事物。 RM（Resource Manager）资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或者回滚。 UNDO_LOG表：回滚日志 UNDO_LOG必须在每个业务数据库创建，用于保存回滚操作数据 当全局提交时，UNDO_LOG记录直接删除 当全局回滚时，将现有数据撤销，还原至操作前的状态 AT模式AT模式运行机制AT模式的特点就说对业务无入侵式，整体机制分二阶段提交 两阶段提交协议的演变： 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源 二阶段： 提交异步化，非常快速的完成 回滚通过一阶段的回滚日志进行反向补偿 在AT模式下，用户只需要关注自己的业务sql，用户的业务sql作为一阶段，Seata框架会自动生成事务的二阶段提交和回滚操作。","categories":[],"tags":[]}],"categories":[],"tags":[]}